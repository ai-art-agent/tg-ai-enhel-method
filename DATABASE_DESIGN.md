# База данных и уведомления: архитектура

Одна общая база данных (один SQLite-файл), три логических блока: **клиенты (анкеты)**, **заказы/оплаты**, **доступ**. Все даты храним в UTC, в коде и отчётах используем московское время (Europe/Moscow).

---

## 1. Одна БД или три?

**Рекомендация: одна база данных.**

- **clients** — анкеты (профиль, диагностика, outcome) по `user_id`; нужны и без оплаты (напоминания, повторные контакты, бот Pro).
- **orders** — все заказы (вебинар, групповые, Pro) с датой оплаты и сроком доступа где нужно.
- Связь: по `user_id` / `chat_id`; по заказам видно, кто что купил. Один источник правды для напоминаний и подписок.

Файл БД задаётся `PAYMENTS_DB_PATH` (тот же `payments.sqlite3` или отдельный, например `data.sqlite3` — как удобнее).

---

## 2. Таблицы и поля (соответствие JSON)

### 2.1. `clients` — анкеты (формат как в JSON промпта)

| Поле | Тип | Описание |
|------|-----|----------|
| user_id | INTEGER | Telegram user_id (PK) |
| chat_id | INTEGER | Telegram chat_id |
| username | TEXT | @username (если есть) |
| first_name | TEXT | Имя из профиля |
| last_name | TEXT | Фамилия |
| contact_channel | TEXT | Telegram / Сотовый / Другое |
| contact_value | TEXT | @username, телефон или описание |
| profile_name | TEXT | Как обращаться (из диалога) |
| form_address | TEXT | Женщина / Мужчина / Нейтральная |
| age_group | TEXT | Возрастная группа |
| focus | TEXT | Описание состояния/запроса |
| duration | TEXT | Длительность состояния |
| previous_attempts | TEXT | Предыдущие попытки справиться |
| conflict | TEXT | Вариант конфликта (1, 2, 3, Свой вариант) |
| self_value_scale | INTEGER | Оценка по шкале |
| insight | TEXT | Микро-инсайт |
| readiness | TEXT | Хочу продолжить / Еще подумаю |
| product | TEXT | Выбранный продукт |
| tariff | TEXT | VIP / Стандарт (для групповых) |
| preferred_contact_time | TEXT | Удобное время связи |
| preferred_group_start | TEXT | Удобная дата старта групповых |
| anket_json | TEXT | Полный JSON анкеты (на случай расширения) |
| updated_at | INTEGER | Unix timestamp (UTC) последнего обновления |

Уникальный ключ: `user_id`. При каждом обновлении анкеты (SHOW_JSON или перед оплатой) делаем UPSERT по `user_id`.

### 2.2. `orders` — заказы (расширение текущей таблицы)

Текущие поля оставляем. Добавляем:

| Поле | Тип | Описание |
|------|-----|----------|
| paid_at | INTEGER | Уже есть — дата/время оплаты (UTC unix). |
| access_until | INTEGER | NULL или unix (UTC) — до какой даты доступ (для Pro — конец периода подписи; для вебинара можно не заполнять или = paid_at). |

Для **Pro** при оплате: `access_until = paid_at + (дней подписи из .env, например 30)`.  
Для **вебинара** и **групповых** можно оставить `access_until = NULL` или ставить при необходимости.

Все даты в БД в UTC (unix timestamp или ISO). При выводе и в кроне переводим в московское время.

### 2.3. Уведомления по групповым (кто уже получил дайджест)

Вариант без новой таблицы: дважды в день в 12:00 и 16:00 МСК выбираем из `orders` записи с `product_code IN ('group_standard','group_vip')` и `status='paid'`, за период с прошлой рассылки (или за день). Джойним с `clients` по `user_id`, формируем таблицу и шлём в Telegram. Чтобы не дублировать одних и тех же клиентов в одном отчёте, можно считать уникальных по `user_id` за выбранный период или помечать «уже отправляли» — тогда добавить поле `group_notified_at` в `orders` и выставлять его после отправки дайджеста (тогда в дайджест попадают только те, кого ещё не уведомляли, или за последние N часов — как решите).

---

## 3. Сценарии

### 3.1. Сохранение анкеты в БД

- **Вариант A:** при нажатии «Оплатить» сохраняем в `clients` текущий `context.user_data` (профиль, outcome, продукт, тариф) — без полного диагностического JSON.
- **Вариант B:** при вводе пользователем `SHOW_JSON` парсим ответ модели (JSON), валидируем и делаем UPSERT в `clients`. Так в БД попадает полная анкета.

Лучше сделать оба: при оплате обновлять хотя бы outcome и контакт; при SHOW_JSON — полный дамп по схеме JSON. Тогда анкеты пригодны и без оплаты (напоминания, бот Pro).

### 3.2. Групповые занятия — дайджест в Telegram ✅ реализовано

- В .env: `TELEGRAM_GROUP_NOTIFY_CHAT_ID` — chat_id аккаунта (логина), куда слать таблицу.
- Скрипт **`send_group_digest.py`**: выборка из `orders` (group_standard, group_vip, status=paid) за последние N часов, таблица с датой (МСК), user_id, chat_id, тариф, сумма; отправка в Telegram (HTML, моноширинный блок).
- Расписание: запуск в **12:00 и 16:00 МСК** через cron (см. `deploy/cron_group_digest.example`). В 12:00 — за последние 12 ч, в 16:00 — за последние 4 ч.
- Требуется в .env: `TELEGRAM_BOT_TOKEN`, `TELEGRAM_GROUP_NOTIFY_CHAT_ID`, `PAYMENTS_DB_PATH`.

### 3.3. Pro — дата оплаты и доступ по времени

- В `orders` уже есть `paid_at`. Добавить поле `access_until` (unix UTC).
- При оплате Pro (ResultURL): `access_until = paid_at + N дней` (N из .env, например `PRO_SUBSCRIPTION_DAYS=30`).
- Отдельный бот Pro при проверке доступа: по `user_id` смотрит есть ли запись в `orders` с `product_code='pro'`, `status='paid'` и `access_until >= now_utc`. Если да — доступ есть; иначе «подписка истекла» и можно напоминать продлить. Все сравнения времени в UTC, отображение пользователю — в МСК.

### 3.4. Вебинар — только оплатившим доступ

- Достаточно выборки из одной БД: `orders` где `product_code='webinar'` и `status='paid'`. Список `user_id` или `chat_id` — это и есть «кому открыт доступ». Отдельная таблица не обязательна; если понадобится выдача ссылки через другой сервис/бот — он может читать эту выборку или кэш по ней.

### 3.5. Напоминания и подписки (без оплаты / продление)

- Анкеты в `clients` — база для «вернуться к проблеме» и «продлить подписку».
- По `user_id` видно: есть ли оплата, какая (вебинар/групповые/Pro), до какого числа доступ (Pro). Логику «напомнить через N дней» или «напомнить за 3 дня до конца подписки» можно реализовать отдельным воркером/задачей, читающим одну и ту же БД.

---

## 4. Часовой пояс (МСК)

- В коде везде работа с датой/временем: храним в UTC (unix или datetime UTC).
- При записи `paid_at`, `access_until`, `updated_at` — всегда UTC.
- Расписание «12:00 и 16:00 МСК»: в планировщике переводим в UTC (например, через `zoneinfo`: `ZoneInfo("Europe/Moscow")`) и ставим задачу на 09:00 и 13:00 UTC (зимой) или 08:00 и 12:00 UTC (летом), либо использовать cron на сервере в МСК.
- В отчётах и уведомлениях при выводе дат переводим из UTC в МСК для пользователя.

---

## 5. Пошаговая реализация

1. **Миграция БД**  
   Добавить в `orders` колонку `access_until` (INTEGER, NULL). Создать таблицу `clients` с полями выше (при необходимости разнести на 2–3 таблицы — contact, profile, diagnostic, outcome — можно позже; для старта достаточно одной `clients` с плоскими полями или одним JSON-полем `anket_json` плюс ключевые поля для выборок).

2. **Сохранение анкет**  
   При SHOW_JSON парсить JSON из ответа модели и делать upsert в `clients`. При создании заказа при наличии данных в `context.user_data` обновлять в `clients` outcome и контакт по `user_id`.

3. **ResultURL (robokassa_server)**  
   После `mark_paid_if_pending` для продукта `pro` вычислять `access_until = paid_at + N` и обновлять заказ. N из .env (`PRO_SUBSCRIPTION_DAYS`).

4. **Дайджест групповых**  
   Скрипт или фоновый планировщик в боте: 12:00 и 16:00 МСК выбирать оплативших групповые за последние 12 ч, джойн с `clients`, форматировать таблицу, отправлять в `TELEGRAM_GROUP_NOTIFY_CHAT_ID`. Опционально: поле `group_notified_at` в `orders`, чтобы не слать одного клиента дважды.

5. **Pro-бот**  
   При запросе доступа проверять по БД: есть ли оплата Pro с `access_until >= now_utc`. Даты сравнивать в UTC.

6. **Вебинар**  
   Доступ = выборка из `orders` (webinar, paid). При необходимости — простой API или проверка в боте по `user_id`.

Итого: **одна база**, таблицы `clients` и `orders`, все даты в UTC, отчётность и кроны — в МСК. Дальше можно по шагам вносить изменения в код (миграция, сохранение анкет, расчёт `access_until`, дайджест, проверка доступа в Pro).
